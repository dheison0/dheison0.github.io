<!DOCTYPE html>
<html lang="pt">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Aprenda a utilizar uma das funcionalidades mais úteis do python para embrulho de funções.">
  <title>Decoradores em Python</title>
  <link rel="shortcut icon" href="../images/favicon.svg" type="image/x-icon">

  <link rel="stylesheet" href="../css/base.css">
  <link rel="stylesheet" href="../css/post.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
  <link rel="stylesheet" href="../css/dracula.css">
</head>

<body class="flex flex-col">
  <a href="/" class="header-bar flex-center">
    <img src="../images/favicon.svg" alt="Letra D maiúscula sendo a inicial do meu nome" class="header-icon">
    <span class="header-name">Dheison Gomes</span>
  </a>
  <main class="content flex flex-1 flex-col">
    <h2 class="post-title">Decoradores em Python</h2>
    <span class="post-date">Data de publicação: 16:46 - 14/12/2022</span>
    <div class="post-content"><p>Olá pessoal, ontem tive um pequeno problema na hora de usar cache em memória no <a href="https://sanic.dev">Sanic</a> pra aumentar a velocidade de respostas da minha API, eu não estava conseguindo encontrar material na internet em geral e nem na documentação sobre como fazer isso, então resolvi criar minha própria implementação, e isso me trouxe a fazer a postagem de hoje, espero que gostem.</p>
<h2>O que é um decorador?</h2>
<p>Em poucas palavras: Um decorador é uma função que "embrulha" outra função na hora de sua definição.</p>
<p>Isto é útil para filtragem de dados de entrada e outras coisas(no meu caso foi armazenamento de um retorno da função para ser usado posteriormente).</p>
<p>Um exemplo de uso é em bots do Telegram, você pode criar um decorador que só permite a execução de um comando caso quem tenha enviado seja um administrador.</p>
<h2>Criando um decorador</h2>
<p>A criação de decoradores em python é bem fácil, existem dois tipos de decoradores possiveis de serem criados, o mais simples apenas marca uma função e executa um código estático nela, o segundo pode receber argumentos e assim fazer mais decisões sobre o que deve ou não ser feito, aqui eu vou ensinar as duas formas para que não gastem processamento atoa :)</p>
<h3>Decorador simples</h3>
<p>O decorador simples é apenas uma closure com uma função de resposta marcada como "embrulho", a definição é dada usando uma função normal que recebe a função desenvolvida pelo usúario como argumento e dentro dessa função principal é definida outra usando o decorador que marca ela como "embrulho", logo depois essa função marcada é devolvida como resposta da função principal, veja um exemplo:</p>
<pre><code class="language-python"># Esse é o decorador padrão que marca como "embrulho"
from functools import wraps

def meu_decorador(func):
    @wraps(func)
    def embrulho(*args, **kwargs):
        print("Essa função foi embrulhada com o decorador simples")
        # Você também pode salvar o retorno da função e fazer o que quiser com ele
        return func(*args, **kwargs)
    return embrulho
</code></pre>
<p>Para usar esse tipo de decorador você não pode chamá-lo, apenas marcar, se chamá-lo ira ocorrer um erro por falta do argumento <code>func</code> e não ira funcionar!</p>
<p>Veja um exemplo de uso:</p>
<pre><code class="language-python">@meu_decorador
def ola():
    print("Olá, Mundo!")

ola()
</code></pre>
<p>A execução desse código vai resultar na seguinte saida no terminal:</p>
<pre><code class="language-plain">Essa função foi embrulhada com o decorador simples
Olá, Mundo!
</code></pre>
<p>Caso ainda duvide de ocorrer um erro se chamar o decorador é só você mesmo testar por ai, use <code>@meu_decorador()</code> no lugar de <code>@meu_decorador</code>.</p>
<p>Obs: Se você definir o parâmetro <code>func</code> manualmente é possivel usar o decorador como closure normal, mas isso é meio inútil.</p>
<h3>Decorador que aceita argumentos</h3>
<p>Agora chegamos no decorador legal, esse tem mais utilidade que o anterior por poder receber argumentos que ajudam nas decisões.</p>
<p>O jeito de fazer esse é praticamente o mesmo, mas você cria uma função que contem o decorador simples e retorna ele como resposta, nessa função você pode definir parâmetros para receber os argumentos. Ao cotrário da anterior, nessa versão você não recebe a função desenvolvida na principal, apenas no decorador que vai ser retornado.</p>
<p>Veja um exemplo de como esse é desenvolvido:</p>
<pre><code class="language-python">from functools import wraps
from time import sleep

def demora(n: int):
    def decorador(func):
        primeira_execucao: bool = True
        @wraps(func)
        def embrulho(*args, **kwargs):
            nonlocal primeira_execucao
            print("Essa função foi embrulhada pelo decorador que recebe argumentos")
            if primeira_execucao:
                print(f"Esperando {n} segundos para que a função seja executada pela primeira vez")
                sleep(n)
                primeira_execucao = False
            return func(*args, **kwargs)
        return embrulho
    return decorador
</code></pre>
<p>Aqui nós recebemos um argumento <code>n</code> que diz o tempo demorado para a primeira execução da função, e guardamos a informação de se é a primeira execução em uma variável no escopo do decorador que é usada dentro do embrulho, mas para que essa variável seja manipulada é preciso o uso da palavra chave <code>nonlocal</code> já que a variável não é local e nem global, ela esta um escopo acima de onde esta sendo usada. Um detalhe é que qualquer informação que deseje ser permanente deve estar no escopo do decorador, e não no do embrulho.</p>
<p>Agora caso você use esse decorador em uma função, ela ira demorar <code>n</code> segundos para ser executada pela primeira vez e nas posteriores ira executar de imediato, veja mais esse exemplo:</p>
<pre><code class="language-python">@demora(2)
def ola2(nome: str):
    print(f"Olá, {nome}!")

ola2("João")
ola2("Maria")
</code></pre>
<p>Esse código ira resultar na seguinte saída:</p>
<pre><code class="language-plain">Essa função foi embrulhada pelo decorador que recebe argumentos
Esperando 2 segundos para que a função seja executada pela primeira vez
Olá, João!
Essa função foi embrulhada pelo decorador que recebe argumentos
Olá, Maria!
</code></pre>
<p>Veja que na segunda execução ele já não tem mais a demora de 2 segundos que na primeira vez, isso é porque guardamos a informação de que era primeira execução em uma variável no escopo do decorador, que não é executado toda vez que a função é chamada, apenas em sua criação.</p>
<p>É isso! Espero que tenham gostado e obrigado por ler ate aqui ;)</p>
</div>
  </main>
  <footer class="footer-bar flex-center">
    <span>Feito por <a href="https://github.com/dheison0/dheison0.github.io">Dheison Gomes!</a></span>
    <span>Ícones obtidos no <a href="https://www.svgrepo.com">SVG Repo.</a></span>
  </footer>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</body>

</html>